Input := (itm_id, c_id, w, l, h) -> (itm_id, c_id, v), v = w * l * h
@Preprocessing
 - Input 을  c_id 별로 묶음

// c_id 별로 묶음
@Problem

V := (v0, v1, v2 ... vn) 
T := constant, basket의 volume 

V를 disjoint set 으로 나눈다고 하자. 이 때 disjoint set의 값들의 합이 T를 넘지 않게 넣는다고 할 때, T 개수의 최소값을 구하기.


@Preporcesiing
 - v_k > T인 v_k 들은 필터링
 

@Idea

- brute force + pruning
- 상자 개수의 approximation 값을 구하고 (e.g sigma(v)/T) 여기에 대입해본다. 항상 이 값보다는 상자 개수가 크거나 같은 것을 알 수 있다. 
- greedy : 물건들을 상자에 넣을 때, 상자의 여분 값의 합이 가장 작게 greedy 쓰기
- knapsack + approximation / bounded knapsack 
 => 가방 용량이 T인 것들이 여러개 있을 때, residual의 합이 최소값이 되게
 
 knapsack은 weight, value 목록이 주어질 때, 특정 weight값을 넘지 않으면서 value를 최대화 하는 것
 
 이 문제는, volume, 어떤 value가 주어질 때, 특정 volume값을 넘지않으면서 value를 최대화하는 것 :
  - 가정 : value란, 한 상자에 최대한 많이 들어가는거 
  
 근사 : 여기서 value 는 잔차. residual 은 넣는 상품의 부피가 클수록 작아진다. 즉, value = -v 로 하고  
// MINIMAM SPAN
http://www.tcs.tifr.res.in/~prahladh/teaching/2009-10/limits/lectures/lec02.pdf
// APPROXIMATION MINIMUN KNAPSACK
https://opus.uleth.ca/bitstream/handle/10133/1304/islam,%20mohammed.pdf
// COURSERA
https://www.coursera.org/lecture/approximation-algorithms-part-1/lecture-approximation-scheme-shgaf
//KNAPSACK APPROXI
http://www.cs.otago.ac.nz/cosc341/notes/L25_2018.pdf
// Bounded knapsack
http://www.or.deis.unibo.it/kp/Chapter3.pdf
// FPTAS
http://math.mit.edu/~goemans/18434S06/knapsack-katherine.pdf
https://ocw.mit.edu/courses/sloan-school-of-management/15-083j-integer-programming-and-combinatorial-optimization-fall-2009/lecture-notes/MIT15_083JF09_lec21.pdf
// KNAPSACK 자료
http://web.cs.iastate.edu/~cs511/handout08/Approx_Knapsack.pdf
E.G
T := 7
V := 1, 3, 3, 3, 5, 6





 

